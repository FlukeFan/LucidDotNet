<?xml version="1.0" encoding="utf-8" ?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

  <PropertyGroup>

    <Version>0.0.1</Version>

    <PreserveCompilationContext Condition="$(IsTestProject)=='true'">true</PreserveCompilationContext>
    <CoverageTarget Condition="'$(CoverageTarget)'==''">70</CoverageTarget>
    <NoCoverage Condition="'$(NoCoverage)'==''">false</NoCoverage>

    <BuildUtil>$(MSBuildThisFileDirectory)\BuildUtil\bin\Debug\netcoreapp2.1\Build.BuildUtil.dll</BuildUtil>
    <AltCover>$(NuGetPackageRoot)altcover\5.0.665\tools\netcoreapp2.0\AltCover.dll</AltCover>
    <VsTestConsole>$(MSBuildExtensionsPath)vstest.console.dll</VsTestConsole>
    <ReportGenerator>$(NuGetPackageRoot)reportgenerator\4.0.11\tools\netcoreapp2.0\ReportGenerator.dll</ReportGenerator>

    <TestAssembly>$(AssemblyName).dll</TestAssembly>
    <Quot>"</Quot>
    <SafeFilterTest>$([System.String]::Copy($(FilterTest)).Replace("/", "_fs_").Replace("\", "_bs_").Replace(":", "_col_").Replace("*", "_ast_").Replace("?", "_q_").Replace($(Quot), "_quot_").Replace("&gt;", "_gt_").Replace("&lt;", "_lt_").Replace("|", "_pipe_").Replace(" ", "__"))</SafeFilterTest>
    <TestSuccessFlag>$(AssemblyName).noCoverage$(NoCoverage)_$(SafeFilterTest).success.flg</TestSuccessFlag>
    <CoverageOutput>$(AssemblyName).coverage.xml</CoverageOutput>

  </PropertyGroup>

  <ItemGroup>
    <TestDependencies Include="$(OutDir)\$(AssemblyName).dll" />
    <TestDependencies Include="../**/*.cshtml" />
  </ItemGroup>

  <ItemGroup>
    <CoverageAssemblyFilter Include="NUnit3.TestAdapter" />
    <CoverageAssemblyFilter Include="Lucid.Infrastructure.Lib" />
    <CoverageTypeFilter Include="AutoGeneratedProgram" />
  </ItemGroup>

  <Target Name="BeforeBuildComplete" BeforeTargets="AfterBuild">
    <CallTarget Targets="RunTests" Condition="$(IsTestProject)=='true'" />
  </Target>

  <Target Name="RunTests" Condition="'$(RunTests)'=='true' or '$(FilterTest)'!=''" Inputs="@(TestDependencies)" Outputs="$(OutDir)$(TestSuccessFlag)">
    <CallTarget Targets="RunTestsWithoutCoverage" Condition="'$(FilterTest)'!='' Or '$(NoCoverage)'=='true'" />
    <CallTarget Targets="RunTestsWithCoverage" Condition="'$(FilterTest)'=='' And '$(NoCoverage)'!='true'" />
  </Target>

  <Target Name="RunTestsWithoutCoverage">
    <PropertyGroup>
      <TestStartTime>$([System.DateTime]::Now.AddSeconds(1).ToString(yyyy-MM-dd HH:mm:ss))</TestStartTime>
      <TestCaseFilterOption Condition="'$(FilterTest)'!=''">--testcasefilter:$(FilterTest)</TestCaseFilterOption>
    </PropertyGroup>
    <Message Importance="high" Text="Running tests: $(TestAssembly) without coverage $(TestCaseFilterOption)" />
    <ColorExec WorkingDirectory="$(OutDir)" Command="dotnet.exe &quot;$(VsTestConsole)&quot; $(TestAssembly) --logger:trx $(TestCaseFilterOption)" />
    <Touch Files="$(OutDir)$(TestSuccessFlag)" Time="$(TestStartTime)" AlwaysCreate="true" />
  </Target>

  <Target Name="RunTestsWithCoverage">
    <PropertyGroup>
      <TestStartTime>$([System.DateTime]::Now.AddSeconds(1).ToString(yyyy-MM-dd HH:mm:ss))</TestStartTime>
    </PropertyGroup>
    <Message Importance="high" Text="Running tests with coverage: $(TestAssembly)" />
    <ColorExec WorkingDirectory="$(OutDir)" Command="dotnet $(AltCover) --opencover --save --outputDirectory __Instrumented --xmlReport $(CoverageOutput) --assemblyFilter &quot;@(CoverageAssemblyFilter)&quot; --typeFilter &quot;@(CoverageTypeFilter)&quot; --methodFilter &quot;@(CoverageMethodFilter)&quot; --attributeFilter &quot;@(CoverageAttributeFilter)&quot;" />
    <ColorExec WorkingDirectory="$(OutDir)\__Instrumented" Command="dotnet.exe &quot;$(VsTestConsole)&quot; $(TestAssembly) --logger:trx" />
    <ColorExec WorkingDirectory="$(OutDir)" Command="dotnet $(AltCover) Runner --collect -r __Instrumented" />
    <RemoveDir Directories="$(OutDir)CoverageReport" />
    <ColorExec WorkingDirectory="$(OutDir)" Command="dotnet $(ReportGenerator) -reports:$(CoverageOutput) -targetdir:CoverageReport -verbosity:Error -ReportTypes:Html;XmlSummary" />
    <ColorExec Command="dotnet &quot;$(BuildUtil)&quot; VerifyCoverage $(CoverageTarget) $(OutDir)CoverageReport/Summary.xml" />
    <Touch Files="$(OutDir)$(TestSuccessFlag)" Time="$(TestStartTime)" AlwaysCreate="true" />
  </Target>

  <Target Name="CopyPackageContents" Condition="'$(CopyPackageContent)' == 'true'" BeforeTargets="Compile" Inputs="$(MSBuildProjectDirectory)/obj/project.assets.json" Outputs="bin/content/lastUpdated.flg">
    <ColorExec Command="dotnet &quot;$(BuildUtil)&quot; CopyPackageContents &quot;$(MSBuildProjectDirectory)/obj/project.assets.json&quot; &quot;$([System.String]::Copy($(NuGetPackageRoot)).TrimEnd('\'))&quot;" />
    <Touch Files="bin/content/lastUpdated.flg" AlwaysCreate="true" />
  </Target>

  <UsingTask
    TaskName="ColorExec"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="$(NuGetPackageRoot)roslyncodetaskfactory\2.0.7\build\netstandard2.0\RoslynCodeTaskFactory.dll" >
    <ParameterGroup>
      <WorkingDirectory ParameterType="System.String" />
      <Command ParameterType="System.String" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System.Diagnostics"/>
      <Using Namespace="System.Threading"/>
      <Code Type="Fragment" Language="cs">
<![CDATA[
  using (var process = new Process())
  {
      var firstSpace = Command.IndexOf(' ');

      if (firstSpace > 0)
      {
        process.StartInfo.FileName = Command.Substring(0, firstSpace);
        process.StartInfo.Arguments = Command.Substring(firstSpace + 1, Command.Length - firstSpace - 1);
      }
      else
      {
        process.StartInfo.FileName = Command;
      }

      if (!System.String.IsNullOrWhiteSpace(WorkingDirectory))
        process.StartInfo.WorkingDirectory = WorkingDirectory;

      using (AutoResetEvent outputWaitHandle = new AutoResetEvent(false))
      using (AutoResetEvent errorWaitHandle = new AutoResetEvent(false))
      {
        var redirectOutput = BuildEngine2.IsRunningMultipleNodes;

        if (redirectOutput)
        {
          process.StartInfo.RedirectStandardOutput = true;
          process.StartInfo.RedirectStandardError = true;

          process.OutputDataReceived += (sender, eventArgs) =>
          {
            if (eventArgs.Data == null)
              outputWaitHandle.Set();
            else
              Log.LogMessage(MessageImportance.High, eventArgs.Data);
          };

          process.ErrorDataReceived += (sender, eventArgs) =>
          {
            if (eventArgs.Data == null)
              outputWaitHandle.Set();
            else
              Log.LogError(eventArgs.Data);
          };
        }

        process.StartInfo.UseShellExecute = false;

        Log.LogMessage(MessageImportance.High, $"Starting {process.StartInfo.FileName} {process.StartInfo.Arguments} (in {process.StartInfo.WorkingDirectory}) redirectOutput={redirectOutput}");

        process.Start();

        if (redirectOutput)
        {
          process.BeginOutputReadLine();
          process.BeginErrorReadLine();
        }

        process.WaitForExit();
      }
  }]]>
      </Code>
    </Task>
  </UsingTask>

</Project>